# -*- coding: utf-8 -*-
"""aghata_efeito

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PPHH5M2sYHSw9WeAgxxaL_iwuj6P8c3J

# Planejamento Fatorial em Química

**Autor:** André Simão, aluno de graduação do curso de bacharelado em química tecnológica pela UFSCar.\
\
**Objetivo geral:** Automatizar tratamento de dados para planejamento fatorial completo para experimentos de 2^4. Dessa forma, a aplicabilidade do programa é em foco para facilitar e aumentar a eficiência do trabalho de experimentadores que não possuem proficiência em linguagem de programação.\
\
**Corpo do projeto:** O desenvolvimento das rotinas em plannejamento fatorial será dividida conforme o conteúdo ofericido pelo curso de Introdução a Quimiometria ministrado pelo Prof. Dr. Edenir Rodrigues Pereira Filho. Tendo em vista esta organização, a divisão de funções será constituido em quatro principais tópicos: planejamento fatorial completo, planejamento fatorial fracionário e construção de modelos de regressão.\
\
**Referências bibliográficas:**\
[1]. Pereira Filho, Edenir R. "Planejamento fatorial em química: maximizando a obtenção de resultados." Edufscar: São Carlos (2015).\
\
[2]. Pereira, Fabíola Manhas Verbi, and Edenir Rodrigues Pereira-Filho. "Aplicação de programa computacional livre em planejamento de experimentos: um tutorial." Química Nova 41 (2018): 1061-1071.\
\
[3]. Teófilo, Reinaldo F., and Márcia Ferreira. "Quimiometria II: planilhas eletrônicas para cálculos de planejamentos experimentais, um tutorial." Química nova 29 (2006): 338-350.\

# Bibliotecas
"""

import pandas as pd 
import numpy as np 
import matplotlib.pyplot as plt
import matplotlib.pylab as plt
import matplotlib.gridspec as gridspec
from matplotlib.backends.backend_pdf import PdfPages
from scipy.stats import norm
import seaborn as sns
from scipy import stats

"""# Planejamento Fatorial Completo

**CAPÍTULO 1: PLANEJAMENTO FATORIAL EM QUÍMICA.**

## Leitura e limpeza de dados (Excel)

O primeiro passo é realizar a leitura de dados, neste rotina de planejamento fatorial completo não será inclusa a etapa de codificação dos resultados experimentais. O programa necessariamente realiza a leitura da tabela com os resultados experimentais dos 16 experimentos, pois trata-se de dois níveis e 4 variaveis, juntamente com a interação das variáveis, indicada pela Figura 1.\
\
Figura 1. Modelo de tabela recebida pelo arquivo 'efeitos.xlsm'.
 ![Screenshot_74.png](data:image/png;base64,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)\
 \
Após a leitura, a tabela sofre uma modificação através do método .iloc da biblioteca Pandas para selecionar somente o efeito das variáveis em seguido é realizado os cálculos de efeitos, quadrado dos efeitos e porcentagem de contribuição dos quadrados de efeitos em relação a soma.
"""

def leitura():
  leitura1 = pd.read_excel('efeitos.xlsm')
  dados1 = leitura1.iloc[:,6:21]
  return dados1,leitura1

"""## Cálculo de efeitos

O cáculo de efeitos, neste caso, é dado pela diferença da média das respostas de nível alto e baixo, indicado pela pela equação 1.\
\
Equação 1. Efeito para as variáveis e interações. [3] \
![Screenshot_75.png](data:image/png;base64,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)
"""

def efeitos(dados1):
  soma1=[]
  for i in range(15):
      s = dados1.iloc[:,i]
      soma1.append(sum(s))
      somas1 = np.array(soma1)
  efeitos1 = somas1/8
  efeitor1 = []
  for i in efeitos1:
    efeitor1.append(i)
  return efeitor1

def efeitos_sort(efeitor1):
  index= [1,2,3,4,12,13,14,23,24,34,123,124,134,234,1234]
  efeito1 = pd.Series(efeitor1, index=index, name='Efeitos/Quadrado/Porcentagem')
  efeito3 = efeito1.sort_values()
  return efeito3

"""## Quadrado dos efeitos

É dado pelo quadrado dos efeitos de cada variável e interação, indicado pela Equação.\
\
Equação 2: Quadrados dos efeitos.\
\
**quadrado = (efeitos)²**
"""

def quadrado(efeito3):
  quadrado1 = efeito3**2
  return quadrado1

"""## Porcentagem

A porcentagem de contribuição de cada efeitos é calculado com a relação do quadrados dos efeitos com o somatório dos quadrados dos efeitos de cada variável e interação, indicado pela Equação 3.\
\
Equação 3. Porcentagem de contribuição de cada efeitos.\
\
![Screenshot_77.png](data:image/png;base64,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)
"""

def porcentagem(quadrado1):
  porcentagem1= quadrado1/sum(quadrado1)
  return porcentagem1

"""## Início, fim, centro e z"""

#n_int = int(input('Qual o número de variáveis e interações?: '))
n_int = 15
fim = []
inicio = [0]
centro = []
gauss = []
inc = (1/(n_int))
for i in range(n_int):
   fim.append(inicio[i] + inc)
   inicio.append(fim[i])
   centro.append((inicio[i]+fim[i])/2)
   gauss.append(norm.ppf(centro))
z = []
for j in gauss[n_int-1]:
  z.append(j)
del inicio[n_int]

def gaussiana():  
  #n_int = int(input('Qual o número de variáveis e interações?: '))
  n_int = 15
  fim = []
  inicio = [0]
  centro = []
  gauss = []
  inc = (1/(n_int))
  for i in range(n_int):
    fim.append(inicio[i] + inc)
    inicio.append(fim[i])
    centro.append((inicio[i]+fim[i])/2)
    gauss.append(norm.ppf(centro))
  z = []
  for j in gauss[n_int-1]:
    z.append(j)
  del inicio[n_int]
  return n_int,fim,inicio,centro,z

z

"""## Construção do dataframe com os resultados

"""

def dados_g1(efeito3, quadrado1,porcentagem1,inicio,fim,centro,z):
  index1 = efeito3.index
  colunas1 = {'Efeitos R1' :efeito3 ,'Quadrado':quadrado1,'Porcentagem':porcentagem1,"Início":inicio,'Fim':fim,'Centro':centro,'Gaussiana':z}
  gauss1 = pd.DataFrame(colunas1, index=index1)
  gauss1 = gauss1.rename_axis('N°')
  return gauss1

"""## Gráficos

### Gráfico 1: Probabilidade (Efeito x z)

### Plot do gráfico 1
"""

#markers=['.',',','o','v','^','<','>','1','2','3','4','8','s','p','P']
#len(markers)

sns.set_theme(style="darkgrid")

def etiqueta(annotations,gauss1): 
  for i,label in enumerate(annotations):
    plt.annotate(label, (list(gauss1.iloc[:,0])[i],list(gauss1.iloc[:,6])[i]))

def grafico1(gauss1):
    annotations = list(gauss1.index)
    plt.figure(figsize=(8,9))
    fig1 = plt.scatter(list(gauss1.iloc[:,0]),list(gauss1.iloc[:,6]),s=40, color='darkred')
    plt.title('Efeito x Gaussiana (z)', fontsize=18, fontweight='black', loc='left')
    plt.ylabel('Gaussiana (z)')
    plt.xlabel('Efeitos')
    etiqueta(annotations,gauss1)
    return fig1

"""### Gráfico 2: Porcentagem de efeito x Interações

### Selecionando dados do dataframe
"""

def dados_g2(porcentagem1):
  x2= np.array(porcentagem1.index)
  y2= porcentagem1.values
  data2= pd.DataFrame({'Efeitos R1': x2, 'Porcentagem (%)': y2})
  return data2



"""### Plot do gráfico 2"""

def grafico2(data2):
    plt.figure(figsize=(8,9))
    tips = sns.load_dataset("tips")
    fig2 = sns.barplot(x='Efeitos R1', y='Porcentagem (%)', data=data2)
    fig2.set_title('Porcentagem x Efeitos', fontsize=16, fontweight='black')
    return fig2

"""# Reorganização do Planejamento

## Variância e Erro de um Efeito

### Variância e Erro Experimental

#### Excluindo variáveis insignificantes
"""

def df_erro1(leitura1):  
  V1 = leitura1['V1'][:16].values
  V2 = leitura1['V2'][:16].values
  V3 = leitura1['V3'][:16].values
  V4 = leitura1['V4'][:16].values
  R = leitura1['R'][:16].values
  col = {'V1': V1, 'V2':V2, 'V3':V3, 'V4':V4, 'R': R}
  exp = pd.Series(list(range(1,17)))
  dados2 = pd.DataFrame(col, index=exp)
  return dados2

def coleta():
  x=0
  var_exp = []
  N=''
  while True:
    x+=1
    if x <= 4:
      var_insg = input(f'Digite a variável {x} insignificante?(V1, V2, V3 ou V4): ')
      N = str(input('Pressione qualquer tecla para continuar para inserir mais uma variável, caso contrário digite "N" para sair. ')).strip().upper()[0]
      var_exp.append(var_insg.upper())
    if N == "N":
      break
      exit()
    if x == 4:
      print('Todas variáveis são insignificantes.')
      break
      exit()
  return var_exp

def tabela_nova1(dados2,cond):
  dados2 = dados2.drop(cond[0], axis='columns')
  a1 = dados2[dados2.T.index[0]].values
  a2 = dados2[dados2.T.index[1]].values
  a3 = dados2[dados2.T.index[2]].values
  a1a2 = a1*a2
  a1a3 = a1*a3
  a2a3 = a2*a3
  dados2.insert(3, f"{dados2.T.index[0]}{dados2.T.index[1]}", a1a2, allow_duplicates=False)
  dados2.insert(4, f"{dados2.T.index[0]}{dados2.T.index[2]}", a1a3, allow_duplicates=False)
  dados2.insert(5, f"{dados2.T.index[1]}{dados2.T.index[2]}", a2a3, allow_duplicates=False)
  dados3 = dados2.sort_values([f'{dados2.T.index[0]}', f'{dados2.T.index[1]}', f'{dados2.T.index[2]}'], ascending=True)
  return dados3
def tabela_nova2(dados2,cond):
  dados2 = dados2.drop(cond[0], axis='columns')
  dados2 = dados2.drop(cond[1], axis='columns')
  a1 = dados2[dados2.T.index[0]].values
  a2 = dados2[dados2.T.index[1]].values
  a1a2 = a1*a2
  dados3 = dados2.insert(2, f"{dados2.T.index[0]}{dados2.T.index[1]}", a1a2, allow_duplicates=False)
  dados3 = dados2.sort_values([f'{dados2.T.index[0]}',f'{dados2.T.index[1]}'], ascending=True)
  return dados3
def tabela_nova3(dados2,cond):
  dados2 = dados2.drop(cond[0], axis='columns')
  dados2 = dados2.drop(cond[1], axis='columns')
  dados2 = dados2.drop(cond[2], axis='columns')
  a1 = dados2[dados2.T.index[0]].values
  dados3 = dados2.sort_values([f'{dados2.T.index[0]}'], ascending=True)
  return dados3

#cond = coleta()
def replicas_inc(cond,dados3):
  if len(cond) == 1:
    #dados3 = tabela_nova1(dados2)
    R2 = []
    for i in range(1,17,2):
      R2.append(dados3['R'].iloc[i])
    replicas = dados3.iloc[:,0:-1]
    replicas = replicas.drop_duplicates()
    replicas['R1'] = dados3['R']
    replicas['R2'] = R2
  if len(cond) == 2:
    #dados3 = tabela_nova2(dados2)
    R=[]
    R2=[]
    R3=[]
    R4=[]
    for i in range(0,16,4):
      R.append(dados3.iloc[i,-1])
    for i in range(1,16,4):
      R2.append(dados3.iloc[i,-1])
    for i in range(2,16,4):
      R3.append(dados3.iloc[i,-1])
    for i in range(3,16,4):
      R4.append(dados3.iloc[i,-1])
    replicas = dados3.iloc[:,0:-1]
    replicas = replicas.drop_duplicates()
    replicas['R1'] = R
    replicas['R2'] = R2
    replicas['R3'] = R3
    replicas['R4'] = R4
  if len(cond) == 3:
    #dados3 = tabela_nova3(dados2)
    R=[]
    R2=[]
    R3=[]
    R4=[]
    R5=[]
    R6=[]
    R7=[]
    R8=[]
    for i in range(0,16,8):
      R.append(dados3.iloc[i,-1])
    for i in range(1,16,8):
      R2.append(dados3.iloc[i,-1])
    for i in range(2,16,8):
      R3.append(dados3.iloc[i,-1])
    for i in range(3,16,8):
      R4.append(dados3.iloc[i,-1])
    for i in range(4,16,8):
      R5.append(dados3.iloc[i,-1])
    for i in range(5,16,8):
      R6.append(dados3.iloc[i,-1])
    for i in range(6,16,8):
      R7.append(dados3.iloc[i,-1])
    for i in range(7,16,8):
      R8.append(dados3.iloc[i,-1])
    replicas = dados3.iloc[:,0:-1]
    replicas = replicas.drop_duplicates()
    replicas['R1'] = R
    replicas['R2'] = R2
    replicas['R3'] = R3
    replicas['R4'] = R4
    replicas['R5'] = R5
    replicas['R6'] = R6
    replicas['R7'] = R7
    replicas['R8'] = R8
  if len(cond) == 4:
    print('Todas variáveis são insignificantes.')
  return replicas

"""#### Selecionando replicatas

#### Construindo tabela de réplicas

### Adicione Tabela de Réplicas Combinada Aqui
Caso contenha mais de uma replicata realize as seguintes instruções:
- Rode o programa o para cada réplica, utilzando os macros do excel para cada réplica. 
- Retire o comentário da célula abaixo "#"
- Depois, pelo Excel, calcule a média das réplicas e monte uma tabela no formato exatamente igual ao apresentado pelo DataFrame aqui acima com o nome *'replicas'*.
"""

#replicas = pd.read_excel('replicas.xlsx')
#cond=4

"""#### Média das Réplicas 

"""

def media_replicas(cond,replicas):
  if len(cond) == 1:
    dados_media = replicas.iloc[:,6:8].T.mean()
    replicas['Média'] = dados_media 
  if len(cond) == 2:
    mr1 = list(replicas.iloc[:1,3:].T.mean().values)
    mr2 = replicas.iloc[1:2,3:].T.mean().values
    mr3 = replicas.iloc[2:3,3:].T.mean().values
    mr4 = replicas.iloc[3:4,3:].T.mean().values
    mean = [mr1,mr2,mr3,mr4]
    mean_r =[]
    for i in mean:
      for j in i:
        mean_r.append(j)
    mean_r
    replicas['Média'] = mean_r
    replicas
  if len(cond) == 3:
    dados_media = replicas.iloc[:,1:9].T.mean()
    replicas['Média'] = dados_media 
  return replicas

"""#### Variância das réplicas"""

def var_replicas(cond, replicas):
  if len(cond) == 1:
    for i in range(replicas.shape[0]):
      dados_var = replicas.iloc[:,6:8].T.var()
    replicas['Variância'] = dados_var
  if len(cond) == 2:
    var_r = []
    for i  in range(1,5):
      var = replicas.iloc[i-1:i,3:7]
      var = var.T.var(axis=0).values
      var_r.append(var[0])
    replicas['Variância'] = var_r
  if len(cond) == 3:
    for i in range(replicas.shape[0]):
      dados_var = replicas.iloc[:,1:9].T.var()
      replicas['Variância'] = dados_var
  return replicas

"""#### Número de experimentos, graus de liberdade, variancia e erro do experimento e de um efeito."""

def exp_eft_dados(cond,replicas):
  # numero e graus de liberdade
  if len(cond) == 1:
    n0 = 2
    gl0 = n0 - 1
    n = []
    gl = []
    for i in range(replicas.shape[0]):
      n.append(n0)
      gl.append(gl0)
    replicas['Nº exp'] = n
    replicas['g.l'] = gl
  if len(cond) == 2:
    n0 = 4
    gl0 = n0 - 1
    n = []
    gl = []
    for i in range(4):
      n.append(n0)
      gl.append(gl0)
    replicas['Nº exp'] = n
    replicas['g.l'] = gl
  if len(cond) == 3:
    n0 = 8
    gl0 = n0 - 1
    n = []
    gl = []
    for i in range(replicas.shape[0]):
      n.append(n0)
      gl.append(gl0)
    replicas['Nº exp'] = n
    replicas['g.l'] = gl
 # variancia e erro do experimento 
  var_exp = replicas['Variância'].mean()
  erro_exp = (var_exp)**(0.5)
  print(f"Variância experimental igual a {var_exp} e Erro experimental igual {erro_exp}")
  replicas['Var_exp'] = var_exp
  replicas['Erro_exp'] = erro_exp
  # erro e variancia de um efeito 
  k = 4-len(cond)
  erro_eft = (2*erro_exp)/((n0*(2**k))**(0.5))
  replicas['Erro_eft'] = erro_eft
  print(f'Erro de um Efeito: {erro_eft}')
  a = replicas[replicas.T.index[2]].values
  a2 = a**2
  sum_a = np.sum(a2)/replicas.shape[0]
  var_eft = sum_a*(var_exp/replicas.shape[0])
  replicas['Var_eft'] = var_eft
  return gl,n

"""### Valor de "t
Em planejamento fatorial é aplicado 95% de confiança geralmente.
"""

# sig = int(input('Digite o nível de significância?(%): '))
def t_value(replicas):
  sig = 95
  valor_t = (stats.t.ppf((1-(sig/100))/2, sum(replicas['g.l'])))*(-1)
  #print(f'Valor de "t": {valor_t}')
  replicas['t-value'] = valor_t
  return valor_t

"""### Selecionados dados médios

"""

def int_eft_replicas(cond,replicas):
  if len(cond) == 1:
    media =  replicas[f'{replicas.T.index[8]}'].values
    col_vmedio = {f'{replicas.T.index[0]}': replicas[f'{replicas.T.index[0]}'],
                  f'{replicas.T.index[1]}': replicas[f'{replicas.T.index[1]}'],
                  f'{replicas.T.index[2]}': replicas[f'{replicas.T.index[2]}'],
                  f'{replicas.T.index[3]}': replicas[f'{replicas.T.index[3]}'],
                  f'{replicas.T.index[4]}': replicas[f'{replicas.T.index[4]}'],
                  f'{replicas.T.index[5]}': replicas[f'{replicas.T.index[5]}'],}
    v_medio = pd.DataFrame(col_vmedio, index = replicas.index)
    eft_medios = []
    for i in range(v_medio.shape[0]):
      efeito = list(v_medio.loc[list(v_medio.index)[i]].values*media[i])
      eft_medios.append(efeito)
    col_vmedio = {f'{v_medio.index.values[0]}':eft_medios[0],
    f'{v_medio.index.values[1]}':eft_medios[1],
    f'{v_medio.index.values[2]}':eft_medios[2],
    f'{v_medio.index.values[3]}':eft_medios[3],
    f'{v_medio.index.values[4]}':eft_medios[4],
    f'{v_medio.index.values[5]}':eft_medios[5],
    f'{v_medio.index.values[6]}':eft_medios[6],
    f'{v_medio.index.values[7]}':eft_medios[7]}
    eft_replicas = pd.DataFrame(col_vmedio, index=v_medio.T.index)
    eft_replicas = eft_replicas.T
  if len(cond) == 2:
    #n_replicas = int(input('Qual o número de réplicas na nova tabela? '))
    v_medias = replicas.iloc[:,:3] #ALTERAR
    v_medias['Médias'] = replicas['Média']
    v1 = [] 
    v2 = []
    v1v2 = [] 
    for i in range(4):
      x = v_medias['Médias'].values[i]
      v1.append(v_medias[v_medias.T.index[0]].values[i]*(x))
      v2.append(v_medias[v_medias.T.index[1]].values[i]*(x))
      v1v2.append(v_medias[v_medias.T.index[0]].values[i]*(x))
    col_vmedio = {f'{v_medias.T.index[0]}':v1, f'{v_medias.T.index[1]}':v2,f'{v_medias.T.index[0]}{v_medias.T.index[1]}':v1v2}
    eft_replicas = pd.DataFrame(col_vmedio, index=v_medias.index)
    eft_replicas
  if len(cond) == 3:
    media =  replicas[f'{replicas.T.index[9]}'].values
    col_vmedio = {f'{replicas.T.index[0]}': replicas[f'{replicas.T.index[0]}'],'Média':media}
    v_medio = pd.DataFrame(col_vmedio, index = replicas.index)
    eft_medios = []
    for i in range(v_medio.shape[0]):
      efeito = v_medio[v_medio.T.index[0]].values[i]*v_medio[v_medio.T.index[1]].values[i]
      eft_medios.append(efeito)
    col_vmedio = {f'{v_medio.T.index[0]}': eft_medios}
    eft_replicas = pd.DataFrame(col_vmedio, index=v_medio.index)
  return eft_replicas

"""### Cálculo de efeitos, quadrado, porcentagem e gaussiana médios

#### Efeitos
"""

def efeitos_replicas1(cond,eft_replicas):  
  if len(cond) == 1:
    efeitor2 = eft_replicas.sum().values/8
  if len(cond) == 2:
    efeitor2=[]
    for i in range(3):
      efeitor2.append(eft_replicas.T.values[i].sum()/8)
  if len(cond) == 3:
    efeitor2=[]
    for i in range(1):
      efeitor2.append(val_medio.T.values[i].sum()/8)
  index_eft = eft_replicas.T.index
  efeitos_replicas = pd.DataFrame({'Efeitos':efeitor2}, index=index_eft)  # Utilizar esta variável no dataframe de efeitos e gaussiana 
  efeitos_replicas = efeitos_replicas.sort_values(by=['Efeitos'])
  return efeitos_replicas,efeitor2

"""#### Quadrado e porcentagem"""

def qdr_por_medio(efeitos_replicas):
  efeitor4 = np.sort(efeitos_replicas)
  qdr_medio = efeitor4**2
  por_medio = qdr_medio/np.sum(qdr_medio)
  return efeitor4, qdr_medio, por_medio

"""#### Início, Fim, Centro e z (tabela de replicatas)"""

def gaussiana_replicas(cond):
  if len(cond) == 1:
    n_int1 = 6
    inicio1 = [0]
    fim1 = []
    centro1 = []
    z0 = []
    inc1 = (1/(n_int1))
    for i in range(n_int1):  
      fim1.append(inicio1[i] + inc1)
      inicio1.append(fim1[i])
      centro1.append((inicio1[i]+fim1[i])/2)
      z0.append(norm.ppf(centro1))
    z0 = z0[n_int1-1] 
    z1 = []
    for j in z0:
      z1.append(j)
    del inicio1[n_int1]
  if len(cond) == 2:  
    #n_int1 = int(input('Qual o número de variáveis e interações?: '))
    n_int1 = 3
    inicio1 = [0]
    fim1 = []
    centro1 = []
    z0 = []
    inc1 = (1/(n_int1))
    for i in range(n_int1):  
      fim1.append(inicio1[i] + inc1)
      inicio1.append(fim1[i])
      centro1.append((inicio1[i]+fim1[i])/2)
      z0.append(norm.ppf(centro1))
    z0 = z0[n_int1-1] 
    z1 = []
    for j in z0:
      z1.append(j)
    del inicio1[n_int1]
    if len(cond) == 3:
      n_int1 = 1
      inicio1 = [0]
      fim1 = []
      centro1 = []
      z0 = []
      inc1 = (1/(n_int1))
      for i in range(n_int1):  
        fim1.append(inicio1[i] + inc1)
        inicio1.append(fim1[i])
        centro1.append((inicio1[i]+fim1[i])/2)
        z0.append(norm.ppf(centro1))
      z0 = z0[n_int1-1] 
      z1 = []
    if cond == 4:
      n_int1 = int(input('Qual o número de experimentos?(%): '))
      inicio1 = [0]
      fim1 = []
      centro1 = []
      z0 = []
      inc1 = (1/(n_int1))
      for i in range(n_int1):  
        fim1.append(inicio1[i] + inc1)
        inicio1.append(fim1[i])
        centro1.append((inicio1[i]+fim1[i])/2)
        z0.append(norm.ppf(centro1))
      z0 = z0[n_int1-1] 
      z1 = []
  dados_efeito_r = (n_int1,inicio1,fim1,centro1,z0)
  return dados_efeito_r

def dados_gr(cond, dados_efeito_r,efeitos_replicas,efeitor4,qdr_medio,por_medio,efeitor2):
  if len(cond) == 1:
    index_r = list(efeitos_replicas.index)
    colunas2 = {'Efeitos':efeitor4, 'Quadrado': qdr_medio, 'Porcentagem': por_medio, 'Início': dados_efeito_r[1],'Fim':dados_efeito_r[2], 'Centro':dados_efeito_r[3], 'Gaussiana':dados_efeito_r[4]}
    gauss2 = pd.DataFrame(colunas2, index=index_r)
  if len(cond) == 2:  
    index_r = list(efeitos_replicas.index)
    colunas2 = {'Efeitos':efeitor2, 'Quadrado': qdr_medio, 'Porcentagem': por_medio, 'Início': dados_efeito_r[1],'Fim':dados_efeito_r[2], 'Centro':dados_efeito_r[3], 'Gaussiana':dados_efeito_r[4]}
    gauss2 = pd.DataFrame(colunas2, index=index_r)
  if len(cond) == 3:  
    index_r = []
    index_r.append(efeitor2.index)
    colunas2 = {'Efeitos':efeitor2, 'Quadrado': qdr_medio, 'Porcentagem': por_medio, 'Início': dados_efeito_r[1],'Fim':dados_efeito_r[2], 'Centro':dados_efeito_r[3], 'Gaussiana':dados_efeito_r[4]}
    gauss2 = pd.DataFrame(colunas2, index=index_r)
  gauss2
  if cond == 4:
    index_r = []
    index_r.append(efeitor2.index)
    colunas2 = {'Efeitos':efeitor2, 'Quadrado': qdr_medio, 'Porcentagem': por_medio, 'Início': dados_efeito_r[1],'Fim':dados_efeito_r[2], 'Centro':dados_efeito_r[3], 'Gaussiana':dados_efeito_r[4]}
    gauss2 = pd.DataFrame(colunas2, index=index_r)
  return gauss2

"""## Intervalo de Confiança"""

def inter_confianca(valor_t, gauss2, gl):
  confianca = (gl[0])**(0.5)*valor_t
  inter_c = [-confianca,0,confianca]
  gauss2['|Inter Confiança|'] = inter_c[2]
  return inter_c

"""## Gráficos - Envolvendo intervalo de confiança e contribuição de efeito"""

def etiquetar1(annotationsr1,gauss2): 
  for i,label in enumerate(annotationsr1):
    plt.annotate(label, (list(gauss2['Efeitos'])[i],list(gauss2['Gaussiana'])[i]))

def dados_inter_c(gauss2, inter_c):
  #Eixo X intervalor de confiança 
  c1 = []
  c2 = []
  c3 = []
  for _ in range(gauss2.shape[0]):
    c1.append(inter_c[0])
    c2.append(inter_c[1])
    c3.append(inter_c[2])
  return c1,c2,c3

def graficos_replicas(gauss2,inter_c):
    annotationsr1 = list(gauss2.index)
    plt.figure(figsize=(8,9))
    ax3 = plt.scatter(list(gauss2['Efeitos']),list(gauss2['Gaussiana']),s=40, color='darkred')
    plt.title('Efeito x Gaussiana (z) - Replicatas', fontsize=18, fontweight='black', loc='left')
    plt.ylabel('Gaussiana (z)')
    plt.xlabel('Efeitos')
    plt.savefig('ProbabilidadeReplicatas.pdf', format='pdf')
    c1,c2,c3 = dados_inter_c(gauss2, inter_c)
    etiquetar1(annotationsr1, gauss2)
    plt.plot(c1,list(gauss2['Gaussiana']))
    plt.plot(c2,list(gauss2['Gaussiana']), color='darkred')
    plt.plot(c3,list(gauss2['Gaussiana']), color= 'black')
    plt.savefig('ProbabilidadeReplicatas.pdf', format='pdf')
    eft_replicas = pd.DataFrame({'Efeitos':gauss2.index, 'Porcentagem (%)':gauss2['Porcentagem']}, index=gauss2.index)
    plt.figure(figsize=(8,9))
    tips = sns.load_dataset("tips")
    ax4 = sns.barplot(x='Efeitos', y='Porcentagem (%)', data=eft_replicas)
    ax4.set_title('Porcentagem x Efeitos', fontsize=16, fontweight='black')
    plt.savefig('EfeitoReplicatas.pdf', format='pdf')
    return ax3,ax4

"""# Resultados finais - Planejamento Fatorial Completo

### Gráfico de probabilidade com intervalo de confiança.
"""

def salvar_planilhas(gauss1,gauss2,replicas):
    writer = pd.ExcelWriter('resultadosfinaisreplicas.xlsx')
    gauss1.to_excel(writer, 'Efeitos-Porcemtagem-Gauss.xlsx')
    gauss2.to_excel(writer, sheet_name='Resultados Replicas')
    replicas.to_excel(writer, sheet_name='replicas.xlsx')
    return writer.save()

"""# Definição da rotina aghata_efeito"""

def dados_efeito():
  dados1,leitura1 = leitura()
  efeito1 = efeitos(dados1)
  efeito3 = efeitos_sort(efeito1)
  quadrado1 = quadrado(efeito3)
  porcentagem1 = porcentagem(quadrado1)
  n_int,fim,inicio,centro,z = gaussiana()
  gauss1 = dados_g1(efeito3, quadrado1,porcentagem1,inicio,fim,centro,z)
  data2 = dados_g2(porcentagem1)
  dados_efeito1 = (dados1,leitura1,efeito1,efeito3,quadrado1,porcentagem1,gauss1,data2) 
  return dados_efeito1

def graficos(): 
   dados_efeito1 = dados_efeito()
   sns.set_theme(style="darkgrid")
   fig1 = grafico1(dados_efeito1[-2])
   plt.savefig('Probabilidade.pdf', format='pdf')
   fig2 = grafico2(dados_efeito1[-1])
   plt.savefig('Efeito.pdf', format='pdf')
   return plt.show()
   #return fig1,fig2

def reorg_pf():
  dados_efeito1 = dados_efeito()
  gfc = graficos()
  dados2 = df_erro1(dados_efeito1[1])
  cond = coleta()
  if len(cond) == 1:
    dados3 = tabela_nova1(dados2,cond)
  if len(cond) == 2:
    dados3 = tabela_nova2(dados2,cond)
  if len(cond) == 3:
    dados3 = tabela_nova3(dados2,cond)
  replicas = replicas_inc(cond,dados3)
  media_replicas(cond,replicas)
  var_replicas(cond, replicas)
  gl,n  =exp_eft_dados(cond,replicas)
  int_eft_replicas(cond,replicas)
  replicas.to_excel('replicas.xlsx')
  valor_t = t_value(replicas)
  eft_replicas = int_eft_replicas(cond,replicas)
  efeitos_replicas,efeitor2 = efeitos_replicas1(cond,eft_replicas)
  efeitor4, qdr_medio, por_medio = qdr_por_medio(efeitor2)
  dados_efeito_r = gaussiana_replicas(cond)
  gauss2 = dados_gr(cond, dados_efeito_r,efeitos_replicas,efeitor4,qdr_medio,por_medio,efeitor2)
  gauss2 = gauss2.sort_values(by=['Efeitos'])
  inter_c = inter_confianca(valor_t, gauss2, gl)
  dados_efeito2 = (dados_efeito1, replicas, valor_t, eft_replicas, efeitor2, efeitor4, gauss2, inter_c)
  return dados_efeito2

def aghata_efeito():
  dados_efeito2 = reorg_pf()
  graficos_replicas(dados_efeito2[-2], dados_efeito2[-1])
  salvar_planilhas(dados_efeito2[0][-2],dados_efeito2[-2],dados_efeito2[1])

aghata_efeito()

